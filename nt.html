<script src="https://unpkg.com/media-shader@latest/media-shader.js"></script>
<media-shader width="100%"
              height="100%"
              fragment-shader='["#version 300 es\n    precision highp float;\n    out vec4 glFragColor;\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\nuniform vec4 u_background;\nuniform float u_phase; \nuniform float u_scale; \nuniform float u_glow; \nuniform float u_distort; \nuniform float u_power; \nuniform float u_speed; \nuniform int u_iterations; \nuniform float u_brightness; \n#define power 1.\n#define zoomOut 10.\n#define rot 1.\n#define huePower 0.7\n#define Speed 1.5\n#define WaveSpeed 2.\n#define Brightness 2.\nvoid main()\n{\n  vec2 uv = gl_FragCoord.xy/u_resolution.xy;\n\tvec2 XYScale = vec2(1.0,1.0);\n\tvec2 XYMove = vec2(0.0,0.0);\n  uv -= vec2(0.5,0.5);\n  float t = u_time;\n  float phase = (u_phase * 10.) * u_speed * sin(t);\n  uv *= zoomOut*(1.0-u_scale);\n\tuv.xy = uv.xy * XYScale;\n\tuv.xy = uv.xy + XYMove;\n\tvec4 finalCol = vec4(0.);\n\tfloat halfDistort = u_distort / 0.5;\n\tfloat distortsc2 = u_distort / u_distort + halfDistort;\n\tfor(float i = 1.0; i < float(u_iterations); i++){\n\t\tuv.x += u_power / i * sin(i * u_distort   * uv.y - phase);\n\t\tuv.y += u_power / i * sin(i * distortsc2 * uv.x + phase);\n\t}\n\tvec4 col = vec4(vec4(u_glow)/sin((t*WaveSpeed*u_speed)-length(uv.yx) - uv.y));\n\tfinalCol = vec4(col*col);\n  vec4 Color = vec4(1.) * Brightness*u_brightness;\n\tColor = Color*Color * 0.5 + 0.5*cos(phase+uv.xyxy +vec4(0,2,4,1.0)) * huePower;\n  Color = finalCol * Color * power;\n  glFragColor = (Color * Color.a) + (u_background * (1. - Color.a));\n}","#version 300 es\n    precision highp float;\n    out vec4 glFragColor;\n        uniform sampler2D u_texture;\n        uniform vec2 u_resolution;\n        uniform float u_time;\n        #define PASS_0 true\n        vec4 filter_getFragColor(vec2 coord){\n            return texture(u_texture, fract(coord));\n        }\n        vec4 filter_getClampedFragColor(vec2 coord){\n            return texture(u_texture, clamp(coord, vec2(0.01), vec2(0.99)) );\n        }\n        vec4 filter_getClampedFragColor(vec2 coord, float edge){\n            return texture(u_texture, clamp(coord, vec2(edge), vec2(1.0 - edge)) );\n        }\n        uniform float u_filter_pixel_size;  \n        #define SAMPLER_FNC(TEX, UV) filter_getClampedFragColor(UV)\n#ifndef NEAREST_FLOOR_FNC\n#define NEAREST_FLOOR_FNC(UV) floor(UV)\n#endif\n#ifndef FNC_NEAREST\n#define FNC_NEAREST\nvec2 nearest(in vec2 v, in vec2 res) {\n    vec2 offset = 0.5 / (res - 1.0);\n    return NEAREST_FLOOR_FNC(v * res) / res + offset;\n}\n#endif\n#ifndef SAMPLER_FNC\n#if __VERSION__ >= 300\n#define SAMPLER_FNC(TEX, UV) texture(TEX, UV)\n#else\n#define SAMPLER_FNC(TEX, UV) texture(TEX, UV)\n#endif\n#endif\n#ifndef SAMPLER_TYPE\n#define SAMPLER_TYPE sampler2D\n#endif\n#ifndef FNC_SAMPLENEAREST\n#define FNC_SAMPLENEAREST\nvec4 sampleNearest(SAMPLER_TYPE tex, vec2 st, vec2 texResolution) {\n    return SAMPLER_FNC( tex, nearest(st, texResolution) );\n}\n#endif\n#ifndef FNC_DECIMATE\n#define FNC_DECIMATE\nfloat decimate(float v, float p){ return floor(v*p)/p; }\nvec2 decimate(vec2 v, float p){ return floor(v*p)/p; }\nvec2 decimate(vec2 v, vec2 p){ return floor(v*p)/p; }\nvec3 decimate(vec3 v, float p){ return floor(v*p)/p; }\nvec3 decimate(vec3 v, vec3 p){ return floor(v*p)/p; }\nvec4 decimate(vec4 v, float p){ return floor(v*p)/p; }\nvec4 decimate(vec4 v, vec4 p){ return floor(v*p)/p; }\n#endif\n#ifndef DITHER_INTERLEAVEDGRADIENTNOISE_COORD\n#define DITHER_INTERLEAVEDGRADIENTNOISE_COORD gl_FragCoord.xy\n#endif\n#ifdef DITHER_TIME\n#define DITHER_INTERLEAVEDGRADIENTNOISE_TIME DITHER_TIME\n#endif\n#ifndef DITHER_INTERLEAVEDGRADIENTNOISE_PRECISION\n#ifdef DITHER_PRECISION\n#define DITHER_INTERLEAVEDGRADIENTNOISE_PRECISION DITHER_PRECISION\n#else\n#define DITHER_INTERLEAVEDGRADIENTNOISE_PRECISION 255\n#endif\n#endif\n#ifndef FNC_DITHER_INTERLEAVEDGRADIENTNOISE\n#define FNC_DITHER_INTERLEAVEDGRADIENTNOISE\nfloat ditherInterleavedGradientNoise(vec2 st) {\n    #ifdef DITHER_INTERLEAVEDGRADIENTNOISE_TIME\n    st += 1337.0*fract(DITHER_INTERLEAVEDGRADIENTNOISE_TIME);\n    #endif\n    st = floor(st);\n    return fract(52.982919 * fract(dot(vec2(0.06711, 0.00584), st))) * 2.0 - 1.0;\n}\nfloat ditherInterleavedGradientNoise(const float value, const vec2 st, const int pres) {\n    float ditherPattern = ditherInterleavedGradientNoise(st);\n    return value + ditherPattern / 255.0;\n}\nvec3 ditherInterleavedGradientNoise(const vec3 color, const vec2 st, const int pres) {\n    #ifdef DITHER_INTERLEAVEDGRADIENTNOISE_CHROMATIC \n    vec3 ditherPattern = vec3(\n            ditherInterleavedGradientNoise(st),\n            ditherInterleavedGradientNoise(st + 0.1337),\n            ditherInterleavedGradientNoise(st + 0.3141));\n    #else\n    vec3 ditherPattern = vec3(ditherInterleavedGradientNoise(st));\n    #endif\n    float d = float(pres);\n    float h = 0.5 / d;\n    return decimate(color - h + ditherPattern / d, d);\n}\nvec3 ditherInterleavedGradientNoise(const vec3 color, const vec2 xy) {  return ditherInterleavedGradientNoise(color, xy, DITHER_INTERLEAVEDGRADIENTNOISE_PRECISION); }\nvec4 ditherInterleavedGradientNoise(const vec4 color, const vec2 xy) {  return vec4(ditherInterleavedGradientNoise(color.rgb, xy, DITHER_INTERLEAVEDGRADIENTNOISE_PRECISION), color.a); }\nfloat ditherInterleavedGradientNoise(const float val, int pres) { return ditherInterleavedGradientNoise(vec3(val),DITHER_INTERLEAVEDGRADIENTNOISE_COORD, pres).r; }\nvec3 ditherInterleavedGradientNoise(const vec3 color, int pres) { return ditherInterleavedGradientNoise(color, DITHER_INTERLEAVEDGRADIENTNOISE_COORD, pres); }\nvec4 ditherInterleavedGradientNoise(const vec4 color, int pres) { return vec4(ditherInterleavedGradientNoise(color.rgb, DITHER_INTERLEAVEDGRADIENTNOISE_COORD, pres), color.a); }\nfloat ditherInterleavedGradientNoise(const float val) { return ditherInterleavedGradientNoise(vec3(val), DITHER_INTERLEAVEDGRADIENTNOISE_COORD, DITHER_INTERLEAVEDGRADIENTNOISE_PRECISION).r; }\nvec3 ditherInterleavedGradientNoise(const vec3 color) { return ditherInterleavedGradientNoise(color, DITHER_INTERLEAVEDGRADIENTNOISE_COORD, DITHER_INTERLEAVEDGRADIENTNOISE_PRECISION); }\nvec4 ditherInterleavedGradientNoise(const vec4 color) { return vec4(ditherInterleavedGradientNoise(color.rgb), color.a); }\n#endif\n#ifndef HIGHP\n#if defined(TARGET_MOBILE) && defined(GL_ES)\n#define HIGHP highp\n#else\n#define HIGHP\n#endif\n#endif\n#ifndef DITHER_VLACHOS_COORD\n#define DITHER_VLACHOS_COORD gl_FragCoord.xy\n#endif\n#ifdef DITHER_TIME\n#define DITHER_VLACHOS_TIME DITHER_TIME\n#endif\n#ifndef DITHER_VLACHOS_PRECISION\n#ifdef DITHER_PRECISION\n#define DITHER_VLACHOS_PRECISION DITHER_PRECISION\n#else\n#define DITHER_VLACHOS_PRECISION 256\n#endif\n#endif\n#ifndef FNC_DITHER_VLACHOS\n#define FNC_DITHER_VLACHOS\nfloat ditherVlachos(float b, vec2 st) {\n    #ifdef DITHER_VLACHOS_TIME\n    st += 1337.0*fract(DITHER_VLACHOS_TIME);\n    #endif\n    HIGHP float noise = dot(vec2(171.0, 231.0), st);\n    noise = fract(noise / 71.0);\n    noise = (noise * 2.0) - 1.0;\n    return b + (noise / 255.0);\n}\nvec3 ditherVlachos(vec2 st) {\n    #ifdef DITHER_VLACHOS_TIME\n    st += 1337.0*fract(DITHER_VLACHOS_TIME);\n    #endif\n    HIGHP vec3 noise = vec3(dot(vec2(171.0, 231.0), st));\n    noise = fract(noise / vec3(103.0, 71.0, 97.0));\n    return noise;\n}\nvec3 ditherVlachos(const in vec3 color, const in vec2 st, const int pres) {\n    float d = float(pres);\n    vec3 ditherPattern = ditherVlachos(st);\n    return decimate(color + ditherPattern / d, d);\n}\nvec3 ditherVlachos(const in vec3 color, const in vec2 xy) {\n    return ditherVlachos(color, xy, DITHER_VLACHOS_PRECISION);\n}\nvec4 ditherVlachos(vec4 color, vec2 st) { return vec4(ditherVlachos(color.rgb, st), color.a);}\nfloat ditherVlachos(float val) { return ditherVlachos(val, DITHER_VLACHOS_COORD);}\nvec3 ditherVlachos(vec3 color) { return ditherVlachos(color, DITHER_VLACHOS_COORD);}\nvec4 ditherVlachos(vec4 color) { return vec4(ditherVlachos(color.rgb), color.a);}\n#endif\n#ifndef DITHER_TRIANGLENOISE_COORD\n#define DITHER_TRIANGLENOISE_COORD gl_FragCoord.xy\n#endif\n#ifdef DITHER_TIME\n#define DITHER_TRIANGLENOISE_TIME DITHER_TIME\n#endif\n#ifdef DITHER_CHROMATIC\n#define DITHER_TRIANGLENOISE_CHROMATIC\n#endif\n#ifndef DITHER_TRIANGLENOISE_PRECISION\n#ifdef DITHER_PRECISION\n#define DITHER_TRIANGLENOISE_PRECISION DITHER_PRECISION\n#else\n#define DITHER_TRIANGLENOISE_PRECISION 255\n#endif\n#endif\n#ifndef FNC_DITHER_TRIANGLENOISE\n#define FNC_DITHER_TRIANGLENOISE\nfloat triangleNoise(HIGHP in vec2 st) {\n    st = floor(st);\n    #ifdef DITHER_TRIANGLENOISE_TIME\n    st += vec2(0.07 * fract(DITHER_TRIANGLENOISE_TIME));\n    #endif\n    st  = fract(st * vec2(5.3987, 5.4421));\n    st += dot(st.yx, st.xy + vec2(21.5351, 14.3137));\n    HIGHP float xy = st.x * st.y;\n    return (fract(xy * 95.4307) + fract(xy * 75.04961) - 1.0);\n}\nvec3 ditherTriangleNoise(const in vec3 color, const HIGHP in vec2 st, const int pres) {\n    #ifdef DITHER_TRIANGLENOISE_CHROMATIC \n    vec3 ditherPattern = vec3(\n            triangleNoise(st),\n            triangleNoise(st + 0.1337),\n            triangleNoise(st + 0.3141));\n    #else\n    vec3 ditherPattern = vec3(triangleNoise(st));\n    #endif\n    float d = float(pres);\n    float h = 0.5/d;\n    return decimate(color - h + ditherPattern / d, d);\n}\nfloat ditherTriangleNoise(const in float b, const HIGHP in vec2 st) { return b + triangleNoise(st) / float(DITHER_TRIANGLENOISE_PRECISION); }\nvec3 ditherTriangleNoise(const in vec3 color, const in vec2 xy) {  return ditherTriangleNoise(color, xy, DITHER_TRIANGLENOISE_PRECISION); }\nvec4 ditherTriangleNoise(const in vec4 color, const in vec2 xy) {  return vec4(ditherTriangleNoise(color.rgb, xy, DITHER_TRIANGLENOISE_PRECISION), color.a); }\nfloat ditherTriangleNoise(const in float val, int pres) { return ditherTriangleNoise(vec3(val),DITHER_TRIANGLENOISE_COORD, pres).r; }\nvec3 ditherTriangleNoise(const in vec3 color, int pres) { return ditherTriangleNoise(color, DITHER_TRIANGLENOISE_COORD, pres); }\nvec4 ditherTriangleNoise(const in vec4 color, int pres) { return vec4(ditherTriangleNoise(color.rgb, DITHER_TRIANGLENOISE_COORD, pres), color.a); }\nfloat ditherTriangleNoise(const in float val) { return ditherTriangleNoise(vec3(val), DITHER_TRIANGLENOISE_COORD, DITHER_TRIANGLENOISE_PRECISION).r; }\nvec3 ditherTriangleNoise(const in vec3 color) { return ditherTriangleNoise(color, DITHER_TRIANGLENOISE_COORD, DITHER_TRIANGLENOISE_PRECISION); }\nvec4 ditherTriangleNoise(const in vec4 color) { return vec4(ditherTriangleNoise(color.rgb), color.a); }\n#endif\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(V) clamp(V, 0.0, 1.0)\n#endif\n#ifndef DITHER_BLUENOISE_COORD\n#define DITHER_BLUENOISE_COORD gl_FragCoord.xy\n#endif\n#ifdef DITHER_TIME\n#define DITHER_BLUENOISE_TIME DITHER_TIME\n#endif\n#ifdef DITHER_CHROMATIC\n#define DITHER_BLUENOISE_CHROMATIC\n#endif\n#ifndef DITHER_BLUENOISE_PRECISION\n#ifdef DITHER_PRECISION\n#define DITHER_BLUENOISE_PRECISION DITHER_PRECISION\n#else\n#define DITHER_BLUENOISE_PRECISION 256\n#endif\n#endif\n#ifndef BLUENOISE_TEXTURE_RESOLUTION\n#define BLUENOISE_TEXTURE_RESOLUTION vec2(1024.0)\n#endif\n#ifndef DITHER_BLUENOISE\n#define DITHER_BLUENOISE\n#ifdef BLUENOISE_TEXTURE\nfloat remap_pdf_tri_unity(float v) {\n    v = v*2.0-1.0;\n    return 0.5 + 0.5 * sign(v) * (1.0 - sqrt(1.0 - abs(v)));\n}\nconst vec2 blueNoiseTexturePixel = 1.0/BLUENOISE_TEXTURE_RESOLUTION;\nfloat ditherBlueNoise(SAMPLER_TYPE tex, const in float value, vec2 st, int pres) {\n    float d = float(pres);\n    #ifdef DITHER_BLUENOISE_TIME \n    st += 1337.0*fract(DITHER_BLUENOISE_TIME);\n    #endif\n    float bn = SAMPLER_FNC(tex, st * blueNoiseTexturePixel).r;\n    float bn_tri = remap_pdf_tri_unity(bn);\n    return value + (bn_tri*2.0-0.5)/d;\n}\nvec3 ditherBlueNoise(SAMPLER_TYPE tex, vec3 color, vec2 st, int pres) {\n    float d = float(pres);\n    #ifdef DITHER_BLUENOISE_TIME\n    st += 1337.0*fract(DITHER_BLUENOISE_TIME * 0.1);\n    #endif\n    #ifdef DITHER_BLUENOISE_CHROMATIC\n    vec3 bn = SAMPLER_FNC(tex, st * blueNoiseTexturePixel).color;\n    vec3 bn_tri = vec3( remap_noise_tri_erp(bn.x), \n                        remap_noise_tri_erp(bn.y), \n                        remap_noise_tri_erp(bn.z) );\n    color += (bn_tri*2.0-1.5)/d;\n    #else\n    float bn = SAMPLER_FNC(tex, st * blueNoiseTexturePixel).r;\n    float bn_tri = remap_pdf_tri_unity(bn);\n    color += (bn_tri*2.0-1.5)/d;\n    #endif\n    return color;\n}\nfloat ditherBlueNoise(SAMPLER_TYPE tex, const in float b, vec2 st) { return ditherBlueNoise(tex, b, st, DITHER_BLUENOISE_PRECISION); }\nvec3 ditherBlueNoise(SAMPLER_TYPE tex, const in vec3 rgb, vec2 st) { return ditherBlueNoise(tex, rgb, st, DITHER_BLUENOISE_PRECISION);}\nvec4 ditherBlueNoise(SAMPLER_TYPE tex, const in vec4 rgba, vec2 st) { return vec4(ditherBlueNoise(tex, rgba.rgb, st), rgba.a); }\nfloat ditherBlueNoise(const in float val) { return ditherBlueNoise(BLUENOISE_TEXTURE, val, DITHER_BLUENOISE_COORD); }\nvec3 ditherBlueNoise(const in vec3 color) { return ditherBlueNoise(BLUENOISE_TEXTURE, color, DITHER_BLUENOISE_COORD); }\nvec4 ditherBlueNoise(const in vec4 color) { return ditherBlueNoise(BLUENOISE_TEXTURE, color, DITHER_BLUENOISE_COORD); }\n#else \nfloat ditherBlueNoise(vec2 p) {\n    const float SEED1 = 1.705;\n    const float size = 5.5;\n    p = floor(p);\n    vec2 p1 = p;\n    #ifdef DITHER_BLUENOISE_TIME\n    p += 1337.0*fract(DITHER_BLUENOISE_TIME * 0.1);\n    #else\n    p += 10.0;\n    #endif\n    p = floor(p/size)*size;\n    p = fract(p * 0.1) + 1.0 + p * vec2(0.0002, 0.0003);\n    float a = fract(1.0 / (0.000001 * p.x * p.y + 0.00001));\n    a = fract(1.0 / (0.000001234 * a + 0.00001));\n    float b = fract(1.0 / (0.000002 * (p.x * p.y + p.x) + 0.00001));\n    b = fract(1.0 / (0.0000235*b + 0.00001));\n    vec2 r = vec2(a, b) - 0.5;\n    p1 += r * 8.12235325;\n    return fract(p1.x * SEED1 + p1.y/(SEED1+0.15555));\n}\nvec3 ditherBlueNoise(const in vec3 color, const in vec2 xy, const int pres) {\n    float d = float(pres);\n    vec3 decimated = decimate(color, d);\n    vec3 diff = (color - decimated) * d;\n    return saturate(decimate(color + step(vec3(ditherBlueNoise(xy)), diff) / d, d));\n}\nfloat ditherBlueNoise(const in float val, const in vec2 xy, const int pres) { return ditherBlueNoise(vec3(val), xy, pres).r; }\nvec4 ditherBlueNoise(const in vec4 color, const in vec2 xy, const int pres) { return vec4(ditherBlueNoise(color.rgb, xy, pres), color.a); }\nfloat ditherBlueNoise(const in float val, const in vec2 xy) { return ditherBlueNoise(vec3(val), xy, DITHER_BLUENOISE_PRECISION).r; }\nvec3 ditherBlueNoise(const in vec3 color, const in vec2 xy) { return ditherBlueNoise(color, xy, DITHER_BLUENOISE_PRECISION); }  \nvec4 ditherBlueNoise(const in vec4 color, const in vec2 xy) {  return vec4(ditherBlueNoise(color.rgb, xy, DITHER_BLUENOISE_PRECISION), color.a); }\nfloat ditherBlueNoise(float val) { return ditherBlueNoise(val, DITHER_BLUENOISE_COORD, DITHER_BLUENOISE_PRECISION); }\nvec3 ditherBlueNoise(vec3 color) { return ditherBlueNoise(color, DITHER_BLUENOISE_COORD, DITHER_BLUENOISE_PRECISION); }\nvec4 ditherBlueNoise(vec4 color) { return ditherBlueNoise(color, DITHER_BLUENOISE_COORD, DITHER_BLUENOISE_PRECISION); }\n#endif\n#endif\n#ifndef DITHER_SHIFT_COORD\n#define DITHER_SHIFT_COORD gl_FragCoord.xy\n#endif\n#ifdef DITHER_TIME\n#define DITHER_SHIFT_TIME DITHER_TIME\n#endif\n#ifdef DITHER_CHROMATIC\n#define DITHER_SHIFT_CHROMATIC\n#endif\n#ifndef DITHER_SHIFT_PRECISION\n#ifdef DITHER_PRECISION\n#define DITHER_SHIFT_PRECISION DITHER_PRECISION\n#else\n#define DITHER_SHIFT_PRECISION 256\n#endif\n#endif\n#ifndef FNC_DITHER_SHIFT\n#define FNC_DITHER_SHIFT\nfloat ditherShift(const in float b, const in vec2 st, const int pres) {\n    float dither_bit = 8.0; \n    #ifdef DITHER_SHIFT_TIME \n    st += 1337.0*fract(DITHER_SHIFT_TIME);\n    #endif\n    float grid_position = fract( dot( st - vec2(0.5,0.5) , vec2(1.0/16.0,10.0/36.0) + 0.25 ) );\n    float dither_shift = (0.25) * (1.0 / (pow(2.0,dither_bit) - 1.0));\n    dither_shift = mix(2.0 * dither_shift, -2.0 * dither_shift, grid_position); \n    return b + 0.5/255.0 + dither_shift; \n}\nvec3 ditherShift(const in vec3 color, const in vec2 st, const int pres) {\n    float dither_bit = 8.0; \n    #ifdef DITHER_SHIFT_TIME \n    st += 1337.0*fract(DITHER_SHIFT_TIME);\n    #endif\n    float grid_position = fract( dot( st - vec2(0.5,0.5) , vec2(1.0/16.0,10.0/36.0) + 0.25 ) );\n    float dither_shift = (0.25) * (1.0 / (pow(2.0,dither_bit) - 1.0));\n    #ifdef DITHER_SHIFT_CHROMATIC\n    vec3 ditherPattern = vec3(dither_shift, -dither_shift, dither_shift);\n    #else\n    vec3 ditherPattern = vec3(dither_shift);\n    #endif\n    ditherPattern = mix(2.0 * ditherPattern, -2.0 * ditherPattern, grid_position); \n    float d = float(pres);\n    float h = 0.5/d;\n    return decimate(color + h + ditherPattern, d);\n}\nfloat ditherShift(const in float value, const in vec2 xy) {  return ditherShift(value, xy, DITHER_SHIFT_PRECISION); }\nvec3 ditherShift(const in vec3 color, const in vec2 xy) {  return ditherShift(color, xy, DITHER_SHIFT_PRECISION); }\nvec4 ditherShift(const in vec4 color, const in vec2 xy) {  return vec4(ditherShift(color.rgb, xy, DITHER_SHIFT_PRECISION), color.a); }\nfloat ditherShift(const in float val, int pres) { return ditherShift(vec3(val),DITHER_SHIFT_COORD, pres).r; }\nvec3 ditherShift(const in vec3 color, int pres) { return ditherShift(color, DITHER_SHIFT_COORD, pres); }\nvec4 ditherShift(const in vec4 color, int pres) { return vec4(ditherShift(color.rgb, DITHER_SHIFT_COORD, pres), color.a); }\nfloat ditherShift(const in float val) { return ditherShift(vec3(val), DITHER_SHIFT_COORD, DITHER_SHIFT_PRECISION).r; }\nvec3 ditherShift(const in vec3 color) { return ditherShift(color, DITHER_SHIFT_COORD, DITHER_SHIFT_PRECISION); }\nvec4 ditherShift(const in vec4 color) { return vec4(ditherShift(color.rgb), color.a); }\n#endif\n#ifndef DITHER_BAKER_COORD\n#define DITHER_BAKER_COORD gl_FragCoord.xy\n#endif\n#ifndef DITHER_BAYER_PRECISION\n#ifdef DITHER_PRECISION\n#define DITHER_BAYER_PRECISION DITHER_PRECISION\n#else\n#define DITHER_BAYER_PRECISION 256\n#endif\n#endif\n#ifndef FNC_DITHER_BAYER\n#define FNC_DITHER_BAYER\n#if defined(PLATFORM_WEBGL)\nfloat ditherBayer(const in vec2 xy) {\n    float x = mod(xy.x, 8.0);\n    float y = mod(xy.y, 8.0);\n    return  mix(mix(mix(mix(mix(mix(0.0,32.0,step(1.0,y)),mix(8.0,40.0,step(3.0,y)),step(2.0,y)),mix(mix(2.0,34.0,step(5.0,y)),mix(10.0,42.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),mix(mix(mix(48.0,16.0,step(1.0,y)),mix(56.0,24.0,step(3.0,y)),step(2.0,y)),mix(mix(50.0,18.0,step(5.0,y)),mix(58.0,26.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),step(1.0,x)),mix(mix(mix(mix(12.0,44.0,step(1.0,y)),mix(4.0,36.0,step(3.0,y)),step(2.0,y)),mix(mix(14.0,46.0,step(5.0,y)),mix(6.0,38.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),mix(mix(mix(60.0,28.0,step(1.0,y)),mix(52.0,20.0,step(3.0,y)),step(2.0,y)),mix(mix(62.0,30.0,step(5.0,y)),mix(54.0,22.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),step(3.0,x)),step(2.0,x)),mix(mix(mix(mix(mix(3.0,35.0,step(1.0,y)),mix(11.0,43.0,step(3.0,y)),step(2.0,y)),mix(mix(1.0,33.0,step(5.0,y)),mix(9.0,41.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),mix(mix(mix(51.0,19.0,step(1.0,y)),mix(59.0,27.0,step(3.0,y)),step(2.0,y)),mix(mix(49.0,17.0,step(5.0,y)),mix(57.0,25.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),step(5.0,x)),mix(mix(mix(mix(15.0,47.0,step(1.0,y)),mix(7.0,39.0,step(3.0,y)),step(2.0,y)),mix(mix(13.0,45.0,step(5.0,y)),mix(5.0,37.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),mix(mix(mix(63.0,31.0,step(1.0,y)),mix(55.0,23.0,step(3.0,y)),step(2.0,y)),mix(mix(61.0,29.0,step(5.0,y)),mix(53.0,21.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),step(7.0,x)),step(6.0,x)),step(4.0,x)) / (64.0);\n}\n#else\nfloat ditherBayer(const in vec2 xy) {\n    float kern[64];\n    kern[ 0] = 0.000; kern[ 1] = 0.500; kern[ 2] = 0.124; kern[ 3] = 0.624; kern[ 4] = 0.028; kern[ 5] = 0.532; kern[ 6] = 0.156; kern[ 7] = 0.656; \n    kern[ 8] = 0.752; kern[ 9] = 0.248; kern[10] = 0.876; kern[11] = 0.376; kern[12] = 0.784; kern[13] = 0.280; kern[14] = 0.908; kern[15] = 0.404; \n    kern[16] = 0.188; kern[17] = 0.688; kern[18] = 0.060; kern[19] = 0.564; kern[20] = 0.216; kern[21] = 0.720; kern[22] = 0.092; kern[23] = 0.596; \n    kern[24] = 0.940; kern[25] = 0.436; kern[26] = 0.812; kern[27] = 0.312; kern[28] = 0.972; kern[29] = 0.468; kern[30] = 0.844; kern[31] = 0.344; \n    kern[32] = 0.044; kern[33] = 0.548; kern[34] = 0.172; kern[35] = 0.672; kern[36] = 0.012; kern[37] = 0.516; kern[38] = 0.140; kern[39] = 0.640; \n    kern[40] = 0.800; kern[41] = 0.296; kern[42] = 0.924; kern[43] = 0.420; kern[44] = 0.768; kern[45] = 0.264; kern[46] = 0.892; kern[47] = 0.392; \n    kern[48] = 0.232; kern[49] = 0.736; kern[50] = 0.108; kern[51] = 0.608; kern[52] = 0.200; kern[53] = 0.704; kern[54] = 0.076; kern[55] = 0.580; \n    kern[56] = 0.988; kern[57] = 0.484; kern[58] = 0.860; kern[59] = 0.360; kern[60] = 0.956; kern[61] = 0.452; kern[62] = 0.828; kern[63] = 0.328;\n    int index = int(mod(xy.x, 8.0)) + (int(mod(xy.y, 8.0)) * 8);\n    #if defined(PLATFORM_WEBGL)\n    for (int i = 0; i < 64; i++) if (i == index) return kern[i];\n    #else\n    return kern[index];\n    #endif\n}\n#endif\nvec3 ditherBayer(vec3 color, const in vec2 xy, const int pres) {\n    float d = float(pres);\n    vec3 decimated = decimate(color, d);\n    vec3 diff = (color - decimated) * d;\n    vec3 ditherPattern = vec3(ditherBayer(xy));\n    return decimate(color + (step(ditherPattern, diff) / d), d);\n}\nfloat ditherBayer(const in float val, const in vec2 xy) { return ditherBayer(vec3(val), xy, DITHER_BAYER_PRECISION).r; }\nvec3 ditherBayer(const in vec3 color, const in vec2 xy) {  return ditherBayer(color, xy, DITHER_BAYER_PRECISION); }\nvec4 ditherBayer(const in vec4 color, const in vec2 xy) {  return vec4(ditherBayer(color.rgb, xy, DITHER_BAYER_PRECISION), color.a); }\nfloat ditherBayer(const in float val, int pres) { return ditherBayer(vec3(val),DITHER_BAKER_COORD, pres).r; }\nvec3 ditherBayer(const in vec3 color, int pres) { return ditherBayer(color, DITHER_BAKER_COORD, pres); }\nvec4 ditherBayer(const in vec4 color, int pres) { return vec4(ditherBayer(color.rgb, DITHER_BAKER_COORD, pres), color.a); }\nfloat ditherBayer(const in float val) { return ditherBayer(vec3(val), DITHER_BAKER_COORD, DITHER_BAYER_PRECISION).r; }\nvec3 ditherBayer(const in vec3 color) { return ditherBayer(color, DITHER_BAKER_COORD, DITHER_BAYER_PRECISION); }\nvec4 ditherBayer(const in vec4 color) { return vec4(ditherBayer(color.rgb), color.a); }\n#endif\n#ifndef DITHER_FNC\n#ifdef TARGET_MOBILE\n#define DITHER_FNC ditherInterleavedGradientNoise\n#else\n#define DITHER_FNC ditherVlachos\n#endif\n#endif\n#ifndef FNC_DITHER\n#define FNC_DITHER\nfloat dither(float v) { return DITHER_FNC(v); }\nvec3 dither(vec3 v) { return DITHER_FNC(v); }\nvec4 dither(vec4 v) { return DITHER_FNC(v); }\n#endif\n#if !defined(GAMMA) && !defined(TARGET_MOBILE) && !defined(PLATFORM_RPI) && !defined(PLATFORM_WEBGL)\n#define GAMMA 2.2\n#endif\n#ifndef FNC_GAMMA2LINEAR\n#define FNC_GAMMA2LINEAR\nfloat gamma2linear(const in float v) {\n#ifdef GAMMA\n    return pow(v, GAMMA);\n#else\n    return v * v;\n#endif\n}\nvec3 gamma2linear(const in vec3 v) {\n#ifdef GAMMA\n    return pow(v, vec3(GAMMA));\n#else\n    return v * v;\n#endif\n}\nvec4 gamma2linear(const in vec4 v) {\n    return vec4(gamma2linear(v.rgb), v.a);\n}\n#endif\n#if !defined(GAMMA) && !defined(TARGET_MOBILE) && !defined(PLATFORM_RPI) && !defined(PLATFORM_WEBGL)\n#define GAMMA 2.2\n#endif\n#ifndef FNC_LINEAR2GAMMA\n#define FNC_LINEAR2GAMMA\nvec3 linear2gamma(const in vec3 v) {\n#ifdef GAMMA\n    return pow(v, vec3(1.0/GAMMA));\n#else\n    return sqrt(v);\n#endif\n}\nvec4 linear2gamma(const in vec4 v) {\n    return vec4(linear2gamma(v.rgb), v.a);\n}\nfloat linear2gamma(const in float v) {\n#ifdef GAMMA\n    return pow(v, 1.0/GAMMA);\n#else\n    return sqrt(v);\n#endif\n}\n#endif\n#ifndef SAMPLEDITHER_FNC\n#define SAMPLEDITHER_FNC ditherBayer\n#endif\n#ifndef FNC_SAMPLEDITHER\n#define FNC_SAMPLEDITHER\nvec4 sampleDither(SAMPLER_TYPE tex, const in vec2 st, const in vec2 resolution) {\n    vec4 color = sampleNearest(tex, st, resolution);\n    gamma2linear(color);\n    color = SAMPLEDITHER_FNC(color, st * resolution);\n    linear2gamma(color);\n    return color;\n}\n#endif\n        vec4 filter_Pixelate() {\n          vec2 pixel = 1.0/u_resolution.xy;\n          vec2 st = gl_FragCoord.xy * pixel;\n          vec4 color = sampleNearest(u_texture, st, u_resolution/u_filter_pixel_size);\n          return color; \n        }\n        void main() {\n        glFragColor = filter_Pixelate();\n        }"]'
              uniforms='[{"u_background":[0,0,0,1],"u_phase":0.5,"u_scale":0.66,"u_glow":0.524,"u_distort":0.5,"u_power":0.482,"u_speed":0.2,"u_iterations":4,"u_brightness":0.478},{"u_filter_pixel_size":42}]'>
</media-shader>