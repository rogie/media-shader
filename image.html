<script src="media-shader.js"></script>

<div style="margin: 20px; font-family: Arial, sans-serif;">
    <h3>Shader embed <button>Play</button></h3>

    <div style="margin: 10px 0; display: inline-block;">
        <label for="tiles-slider">Tiles: <span id="tiles-value">2</span></label><br>
        <input type="range"
               id="tiles-slider"
               min="0"
               max="10"
               value="2"
               step="1"
               style="width: 300px;">
    </div>

    <div style="margin: 10px 0; display: inline-block;">
        <label for="dither-size-slider">Dither Size: <span id="dither-size-value">2</span></label><br>
        <input type="range"
               id="dither-size-slider"
               min="1"
               max="8"
               value="2"
               step="0.1"
               style="width: 300px;">
    </div>

    <div style="margin: 10px 0; display: inline-block;">
        <label for="precision-slider">Precision: <span id="precision-value">2</span></label><br>
        <input type="range"
               id="precision-slider"
               min="1"
               max="32"
               value="2"
               step="1"
               style="width: 300px;">
    </div>
</div>


<media-shader src='1999.mp4'
              playing="false"
              fragment-shader='["#version 300 es\n    precision highp float;\n    out vec4 glFragColor;\n        uniform sampler2D u_texture;\n        uniform vec2 u_resolution;\n        uniform float u_time;\n        #define PASS_0 true\n        vec4 filter_getFragColor(vec2 coord){\n            return texture(u_texture, fract(coord));\n        }\n        vec4 filter_getClampedFragColor(vec2 coord){\n            return texture(u_texture, clamp(coord, vec2(0.01), vec2(0.99)) );\n        }\n        vec4 filter_getClampedFragColor(vec2 coord, float edge){\n            return texture(u_texture, clamp(coord, vec2(edge), vec2(1.0 - edge)) );\n        }\n      uniform float u_filter_tiles; \n      #define SAMPLEUNTILE_SAMPLER_FNC(TEX, UV) filter_getFragColor(UV)\n#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef INV_PI\n#define INV_PI 0.31830988618379067153776752674503\n#endif\n#ifndef INV_SQRT_TAU\n#define INV_SQRT_TAU 0.39894228040143267793994605993439  \n#endif\n#ifndef SQRT_HALF_PI\n#define SQRT_HALF_PI 1.25331413732\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE \n#define GOLDEN_ANGLE 2.39996323\n#endif\n#ifndef FNC_SUM\n#define FNC_SUM\nfloat sum( float v ) { return v; }\nfloat sum( vec2 v ) { return v.x+v.y; }\nfloat sum( vec3 v ) { return v.x+v.y+v.z; }\nfloat sum( vec4 v ) { return v.x+v.y+v.z+v.w; }\n#endif\n#ifndef RANDOM_SCALE\n#ifdef RANDOM_HIGHER_RANGE\n#define RANDOM_SCALE vec4(.1031, .1030, .0973, .1099)\n#else\n#define RANDOM_SCALE vec4(443.897, 441.423, .0973, .1099)\n#endif\n#endif\n#ifndef FNC_RANDOM\n#define FNC_RANDOM\nfloat random(in float x) {\n#ifdef RANDOM_SINLESS\n    x = fract(x * RANDOM_SCALE.x);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n#else\n    return fract(sin(x) * 43758.5453);\n#endif\n}\nfloat random(in vec2 st) {\n#ifdef RANDOM_SINLESS\n    vec3 p3  = fract(vec3(st.xyx) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n#else\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n#endif\n}\nfloat random(in vec3 pos) {\n#ifdef RANDOM_SINLESS\n    pos  = fract(pos * RANDOM_SCALE.xyz);\n    pos += dot(pos, pos.zyx + 31.32);\n    return fract((pos.x + pos.y) * pos.z);\n#else\n    return fract(sin(dot(pos.xyz, vec3(70.9898, 78.233, 32.4355))) * 43758.5453123);\n#endif\n}\nfloat random(in vec4 pos) {\n#ifdef RANDOM_SINLESS\n    pos = fract(pos * RANDOM_SCALE);\n    pos += dot(pos, pos.wzxy + 33.33);\n    return fract((pos.x + pos.y) * (pos.z + pos.w));\n#else\n    float dot_product = dot(pos, vec4(12.9898,78.233,45.164,94.673));\n    return fract(sin(dot_product) * 43758.5453);\n#endif\n}\nvec2 random2(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\nvec2 random2(vec2 p) {\n    vec3 p3 = fract(p.xyx * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\nvec2 random2(vec3 p3) {\n    p3 = fract(p3 * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\nvec3 random3(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx); \n}\nvec3 random3(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\nvec3 random3(vec3 p) {\n    p = fract(p * RANDOM_SCALE.xyz);\n    p += dot(p, p.yxz + 19.19);\n    return fract((p.xxy + p.yzz) * p.zyx);\n}\nvec4 random4(float p) {\n    vec4 p4 = fract(p * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);   \n}\nvec4 random4(vec2 p) {\n    vec4 p4 = fract(p.xyxy * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\nvec4 random4(vec3 p) {\n    vec4 p4 = fract(p.xyzx * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\nvec4 random4(vec4 p4) {\n    p4 = fract(p4  * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n#endif\n#ifndef SAMPLER_FNC\n#if __VERSION__ >= 300\n#define SAMPLER_FNC(TEX, UV) texture(TEX, UV)\n#else\n#define SAMPLER_FNC(TEX, UV) texture(TEX, UV)\n#endif\n#endif\n#ifndef SAMPLER_TYPE\n#define SAMPLER_TYPE sampler2D\n#endif\n#ifndef SAMPLEUNTILE_TYPE\n#define SAMPLEUNTILE_TYPE vec4\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n#ifndef SAMPLEUNTILE_SAMPLER_FNC\n#if defined(PLATFORM_WEBGL) && __VERSION__ >= 300 && defined(GL_OES_standard_derivatives)\n#define SAMPLEUNTILE_SAMPLER_FNC(TEX, UV) textureGrad(TEX, UV, ddx, ddy)\n#else\n#define SAMPLEUNTILE_SAMPLER_FNC(TEX, UV) SAMPLER_FNC(TEX, UV)\n#endif\n#endif\n#ifndef SAMPLEUNTILE_RANDOM_FNC \n#define SAMPLEUNTILE_RANDOM_FNC(XYZ) random4(XYZ) \n#endif\n#ifndef FNC_SAMPLEUNTILE\n#define FNC_SAMPLEUNTILE\nSAMPLEUNTILE_TYPE sampleUntile(SAMPLER_TYPE tex, in vec2 st) {\n    #if defined(PLATFORM_WEBGL) && __VERSION__ >= 300 && defined(GL_OES_standard_derivatives)\n    vec2 ddx = dFdx( st );\n    vec2 ddy = dFdy( st );\n    #endif\n    #ifdef SAMPLEUNTILE_FAST\n    float k = SAMPLEUNTILE_SAMPLER_FNC(tex, 0.005*st ).x; \n    float l = k*8.0;\n    float f = fract(l);\n    #if 0\n    float ia = floor(l); \n    float ib = ia + 1.0;\n    #else\n    float ia = floor(l+0.5); \n    float ib = floor(l);\n    f = min(f, 1.0-f)*2.0;\n    #endif    \n    vec2 offa = sin(vec2(3.0,7.0) * ia); \n    vec2 offb = sin(vec2(3.0,7.0) * ib); \n    SAMPLEUNTILE_TYPE cola = SAMPLEUNTILE_SAMPLER_FNC(tex, st + offa );\n    SAMPLEUNTILE_TYPE colb = SAMPLEUNTILE_SAMPLER_FNC(tex, st + offb );\n    return mix( cola, colb, smoothstep(0.2, 0.8, f - 0.1 * sum(cola-colb) ) );\n    #else \n    vec2 p = floor( st );\n    vec2 f = fract( st );\n    SAMPLEUNTILE_TYPE va = SAMPLEUNTILE_TYPE(0.0);\n    float w1 = 0.0;\n    float w2 = 0.0;\n    for( float y = -1.0; y <= 1.0; y++ )\n    for( float x = -1.0; x <= 1.0; x++ ) {\n        vec2 g = vec2(x, y);\n        vec4 o = SAMPLEUNTILE_RANDOM_FNC( p + g );\n        vec2 r = g - f + o.xy;\n        float d = dot(r,r);\n        float w = exp(-5.0*d );\n        SAMPLEUNTILE_TYPE c = SAMPLEUNTILE_SAMPLER_FNC(tex, st + o.zw); \n        va += w*c;\n        w1 += w;\n        w2 += w*w;\n    }\n    float mean = 0.3;\n    SAMPLEUNTILE_TYPE res = mean + (va-w1*mean)/sqrt(w2);\n    return res;\n    #endif\n}\n#endif\n        vec4 filter_Tile(){\n          vec2 uv = gl_FragCoord.xy/u_resolution;\n          return filter_getFragColor(u_filter_tiles * (uv-0.5));\n        }\n        void main() {\n      glFragColor = filter_Tile();\n        }","#version 300 es\n    precision highp float;\n    out vec4 glFragColor;\n        uniform sampler2D u_texture;\n        uniform vec2 u_resolution;\n        uniform float u_time;\n        #define PASS_0 true\n        vec4 filter_getFragColor(vec2 coord){\n            return texture(u_texture, fract(coord));\n        }\n        vec4 filter_getClampedFragColor(vec2 coord){\n            return texture(u_texture, clamp(coord, vec2(0.01), vec2(0.99)) );\n        }\n        vec4 filter_getClampedFragColor(vec2 coord, float edge){\n            return texture(u_texture, clamp(coord, vec2(edge), vec2(1.0 - edge)) );\n        }\n        uniform bool u_filter_dither_type[7]; \n        uniform float u_filter_dither_size; \n        uniform int u_filter_precision; \n        #define DITHER_PRECISION u_filter_precision\n        #define SAMPLER_FNC(TEX, UV) filter_getClampedFragColor(UV)\n        uniform bool u_invert;\n        uniform float u_brightness;\n        uniform float u_contrast;\n        uniform float u_saturation;\n        uniform float u_shadows;\n        uniform float u_highlights;\n        uniform float u_midtones;\n        uniform float u_luminance_threshold;\n#ifndef NEAREST_FLOOR_FNC\n#define NEAREST_FLOOR_FNC(UV) floor(UV)\n#endif\n#ifndef FNC_NEAREST\n#define FNC_NEAREST\nvec2 nearest(in vec2 v, in vec2 res) {\n    vec2 offset = 0.5 / (res - 1.0);\n    return NEAREST_FLOOR_FNC(v * res) / res + offset;\n}\n#endif\n#ifndef SAMPLER_FNC\n#if __VERSION__ >= 300\n#define SAMPLER_FNC(TEX, UV) texture(TEX, UV)\n#else\n#define SAMPLER_FNC(TEX, UV) texture(TEX, UV)\n#endif\n#endif\n#ifndef SAMPLER_TYPE\n#define SAMPLER_TYPE sampler2D\n#endif\n#ifndef FNC_SAMPLENEAREST\n#define FNC_SAMPLENEAREST\nvec4 sampleNearest(SAMPLER_TYPE tex, vec2 st, vec2 texResolution) {\n    return SAMPLER_FNC( tex, nearest(st, texResolution) );\n}\n#endif\n#ifndef FNC_DECIMATE\n#define FNC_DECIMATE\nfloat decimate(float v, float p){ return floor(v*p)/p; }\nvec2 decimate(vec2 v, float p){ return floor(v*p)/p; }\nvec2 decimate(vec2 v, vec2 p){ return floor(v*p)/p; }\nvec3 decimate(vec3 v, float p){ return floor(v*p)/p; }\nvec3 decimate(vec3 v, vec3 p){ return floor(v*p)/p; }\nvec4 decimate(vec4 v, float p){ return floor(v*p)/p; }\nvec4 decimate(vec4 v, vec4 p){ return floor(v*p)/p; }\n#endif\n#ifndef DITHER_INTERLEAVEDGRADIENTNOISE_COORD\n#define DITHER_INTERLEAVEDGRADIENTNOISE_COORD gl_FragCoord.xy\n#endif\n#ifdef DITHER_TIME\n#define DITHER_INTERLEAVEDGRADIENTNOISE_TIME DITHER_TIME\n#endif\n#ifndef DITHER_INTERLEAVEDGRADIENTNOISE_PRECISION\n#ifdef DITHER_PRECISION\n#define DITHER_INTERLEAVEDGRADIENTNOISE_PRECISION DITHER_PRECISION\n#else\n#define DITHER_INTERLEAVEDGRADIENTNOISE_PRECISION 255\n#endif\n#endif\n#ifndef FNC_DITHER_INTERLEAVEDGRADIENTNOISE\n#define FNC_DITHER_INTERLEAVEDGRADIENTNOISE\nfloat ditherInterleavedGradientNoise(vec2 st) {\n    #ifdef DITHER_INTERLEAVEDGRADIENTNOISE_TIME\n    st += 1337.0*fract(DITHER_INTERLEAVEDGRADIENTNOISE_TIME);\n    #endif\n    st = floor(st);\n    return fract(52.982919 * fract(dot(vec2(0.06711, 0.00584), st))) * 2.0 - 1.0;\n}\nfloat ditherInterleavedGradientNoise(const float value, const vec2 st, const int pres) {\n    float ditherPattern = ditherInterleavedGradientNoise(st);\n    return value + ditherPattern / 255.0;\n}\nvec3 ditherInterleavedGradientNoise(const vec3 color, const vec2 st, const int pres) {\n    #ifdef DITHER_INTERLEAVEDGRADIENTNOISE_CHROMATIC \n    vec3 ditherPattern = vec3(\n            ditherInterleavedGradientNoise(st),\n            ditherInterleavedGradientNoise(st + 0.1337),\n            ditherInterleavedGradientNoise(st + 0.3141));\n    #else\n    vec3 ditherPattern = vec3(ditherInterleavedGradientNoise(st));\n    #endif\n    float d = float(pres);\n    float h = 0.5 / d;\n    return decimate(color - h + ditherPattern / d, d);\n}\nvec3 ditherInterleavedGradientNoise(const vec3 color, const vec2 xy) {  return ditherInterleavedGradientNoise(color, xy, DITHER_INTERLEAVEDGRADIENTNOISE_PRECISION); }\nvec4 ditherInterleavedGradientNoise(const vec4 color, const vec2 xy) {  return vec4(ditherInterleavedGradientNoise(color.rgb, xy, DITHER_INTERLEAVEDGRADIENTNOISE_PRECISION), color.a); }\nfloat ditherInterleavedGradientNoise(const float val, int pres) { return ditherInterleavedGradientNoise(vec3(val),DITHER_INTERLEAVEDGRADIENTNOISE_COORD, pres).r; }\nvec3 ditherInterleavedGradientNoise(const vec3 color, int pres) { return ditherInterleavedGradientNoise(color, DITHER_INTERLEAVEDGRADIENTNOISE_COORD, pres); }\nvec4 ditherInterleavedGradientNoise(const vec4 color, int pres) { return vec4(ditherInterleavedGradientNoise(color.rgb, DITHER_INTERLEAVEDGRADIENTNOISE_COORD, pres), color.a); }\nfloat ditherInterleavedGradientNoise(const float val) { return ditherInterleavedGradientNoise(vec3(val), DITHER_INTERLEAVEDGRADIENTNOISE_COORD, DITHER_INTERLEAVEDGRADIENTNOISE_PRECISION).r; }\nvec3 ditherInterleavedGradientNoise(const vec3 color) { return ditherInterleavedGradientNoise(color, DITHER_INTERLEAVEDGRADIENTNOISE_COORD, DITHER_INTERLEAVEDGRADIENTNOISE_PRECISION); }\nvec4 ditherInterleavedGradientNoise(const vec4 color) { return vec4(ditherInterleavedGradientNoise(color.rgb), color.a); }\n#endif\n#ifndef HIGHP\n#if defined(TARGET_MOBILE) && defined(GL_ES)\n#define HIGHP highp\n#else\n#define HIGHP\n#endif\n#endif\n#ifndef DITHER_VLACHOS_COORD\n#define DITHER_VLACHOS_COORD gl_FragCoord.xy\n#endif\n#ifdef DITHER_TIME\n#define DITHER_VLACHOS_TIME DITHER_TIME\n#endif\n#ifndef DITHER_VLACHOS_PRECISION\n#ifdef DITHER_PRECISION\n#define DITHER_VLACHOS_PRECISION DITHER_PRECISION\n#else\n#define DITHER_VLACHOS_PRECISION 256\n#endif\n#endif\n#ifndef FNC_DITHER_VLACHOS\n#define FNC_DITHER_VLACHOS\nfloat ditherVlachos(float b, vec2 st) {\n    #ifdef DITHER_VLACHOS_TIME\n    st += 1337.0*fract(DITHER_VLACHOS_TIME);\n    #endif\n    HIGHP float noise = dot(vec2(171.0, 231.0), st);\n    noise = fract(noise / 71.0);\n    noise = (noise * 2.0) - 1.0;\n    return b + (noise / 255.0);\n}\nvec3 ditherVlachos(vec2 st) {\n    #ifdef DITHER_VLACHOS_TIME\n    st += 1337.0*fract(DITHER_VLACHOS_TIME);\n    #endif\n    HIGHP vec3 noise = vec3(dot(vec2(171.0, 231.0), st));\n    noise = fract(noise / vec3(103.0, 71.0, 97.0));\n    return noise;\n}\nvec3 ditherVlachos(const in vec3 color, const in vec2 st, const int pres) {\n    float d = float(pres);\n    vec3 ditherPattern = ditherVlachos(st);\n    return decimate(color + ditherPattern / d, d);\n}\nvec3 ditherVlachos(const in vec3 color, const in vec2 xy) {\n    return ditherVlachos(color, xy, DITHER_VLACHOS_PRECISION);\n}\nvec4 ditherVlachos(vec4 color, vec2 st) { return vec4(ditherVlachos(color.rgb, st), color.a);}\nfloat ditherVlachos(float val) { return ditherVlachos(val, DITHER_VLACHOS_COORD);}\nvec3 ditherVlachos(vec3 color) { return ditherVlachos(color, DITHER_VLACHOS_COORD);}\nvec4 ditherVlachos(vec4 color) { return vec4(ditherVlachos(color.rgb), color.a);}\n#endif\n#ifndef DITHER_TRIANGLENOISE_COORD\n#define DITHER_TRIANGLENOISE_COORD gl_FragCoord.xy\n#endif\n#ifdef DITHER_TIME\n#define DITHER_TRIANGLENOISE_TIME DITHER_TIME\n#endif\n#ifdef DITHER_CHROMATIC\n#define DITHER_TRIANGLENOISE_CHROMATIC\n#endif\n#ifndef DITHER_TRIANGLENOISE_PRECISION\n#ifdef DITHER_PRECISION\n#define DITHER_TRIANGLENOISE_PRECISION DITHER_PRECISION\n#else\n#define DITHER_TRIANGLENOISE_PRECISION 255\n#endif\n#endif\n#ifndef FNC_DITHER_TRIANGLENOISE\n#define FNC_DITHER_TRIANGLENOISE\nfloat triangleNoise(HIGHP in vec2 st) {\n    st = floor(st);\n    #ifdef DITHER_TRIANGLENOISE_TIME\n    st += vec2(0.07 * fract(DITHER_TRIANGLENOISE_TIME));\n    #endif\n    st  = fract(st * vec2(5.3987, 5.4421));\n    st += dot(st.yx, st.xy + vec2(21.5351, 14.3137));\n    HIGHP float xy = st.x * st.y;\n    return (fract(xy * 95.4307) + fract(xy * 75.04961) - 1.0);\n}\nvec3 ditherTriangleNoise(const in vec3 color, const HIGHP in vec2 st, const int pres) {\n    #ifdef DITHER_TRIANGLENOISE_CHROMATIC \n    vec3 ditherPattern = vec3(\n            triangleNoise(st),\n            triangleNoise(st + 0.1337),\n            triangleNoise(st + 0.3141));\n    #else\n    vec3 ditherPattern = vec3(triangleNoise(st));\n    #endif\n    float d = float(pres);\n    float h = 0.5/d;\n    return decimate(color - h + ditherPattern / d, d);\n}\nfloat ditherTriangleNoise(const in float b, const HIGHP in vec2 st) { return b + triangleNoise(st) / float(DITHER_TRIANGLENOISE_PRECISION); }\nvec3 ditherTriangleNoise(const in vec3 color, const in vec2 xy) {  return ditherTriangleNoise(color, xy, DITHER_TRIANGLENOISE_PRECISION); }\nvec4 ditherTriangleNoise(const in vec4 color, const in vec2 xy) {  return vec4(ditherTriangleNoise(color.rgb, xy, DITHER_TRIANGLENOISE_PRECISION), color.a); }\nfloat ditherTriangleNoise(const in float val, int pres) { return ditherTriangleNoise(vec3(val),DITHER_TRIANGLENOISE_COORD, pres).r; }\nvec3 ditherTriangleNoise(const in vec3 color, int pres) { return ditherTriangleNoise(color, DITHER_TRIANGLENOISE_COORD, pres); }\nvec4 ditherTriangleNoise(const in vec4 color, int pres) { return vec4(ditherTriangleNoise(color.rgb, DITHER_TRIANGLENOISE_COORD, pres), color.a); }\nfloat ditherTriangleNoise(const in float val) { return ditherTriangleNoise(vec3(val), DITHER_TRIANGLENOISE_COORD, DITHER_TRIANGLENOISE_PRECISION).r; }\nvec3 ditherTriangleNoise(const in vec3 color) { return ditherTriangleNoise(color, DITHER_TRIANGLENOISE_COORD, DITHER_TRIANGLENOISE_PRECISION); }\nvec4 ditherTriangleNoise(const in vec4 color) { return vec4(ditherTriangleNoise(color.rgb), color.a); }\n#endif\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(V) clamp(V, 0.0, 1.0)\n#endif\n#ifndef DITHER_BLUENOISE_COORD\n#define DITHER_BLUENOISE_COORD gl_FragCoord.xy\n#endif\n#ifdef DITHER_TIME\n#define DITHER_BLUENOISE_TIME DITHER_TIME\n#endif\n#ifdef DITHER_CHROMATIC\n#define DITHER_BLUENOISE_CHROMATIC\n#endif\n#ifndef DITHER_BLUENOISE_PRECISION\n#ifdef DITHER_PRECISION\n#define DITHER_BLUENOISE_PRECISION DITHER_PRECISION\n#else\n#define DITHER_BLUENOISE_PRECISION 256\n#endif\n#endif\n#ifndef BLUENOISE_TEXTURE_RESOLUTION\n#define BLUENOISE_TEXTURE_RESOLUTION vec2(1024.0)\n#endif\n#ifndef DITHER_BLUENOISE\n#define DITHER_BLUENOISE\n#ifdef BLUENOISE_TEXTURE\nfloat remap_pdf_tri_unity(float v) {\n    v = v*2.0-1.0;\n    return 0.5 + 0.5 * sign(v) * (1.0 - sqrt(1.0 - abs(v)));\n}\nconst vec2 blueNoiseTexturePixel = 1.0/BLUENOISE_TEXTURE_RESOLUTION;\nfloat ditherBlueNoise(SAMPLER_TYPE tex, const in float value, vec2 st, int pres) {\n    float d = float(pres);\n    #ifdef DITHER_BLUENOISE_TIME \n    st += 1337.0*fract(DITHER_BLUENOISE_TIME);\n    #endif\n    float bn = SAMPLER_FNC(tex, st * blueNoiseTexturePixel).r;\n    float bn_tri = remap_pdf_tri_unity(bn);\n    return value + (bn_tri*2.0-0.5)/d;\n}\nvec3 ditherBlueNoise(SAMPLER_TYPE tex, vec3 color, vec2 st, int pres) {\n    float d = float(pres);\n    #ifdef DITHER_BLUENOISE_TIME\n    st += 1337.0*fract(DITHER_BLUENOISE_TIME * 0.1);\n    #endif\n    #ifdef DITHER_BLUENOISE_CHROMATIC\n    vec3 bn = SAMPLER_FNC(tex, st * blueNoiseTexturePixel).color;\n    vec3 bn_tri = vec3( remap_noise_tri_erp(bn.x), \n                        remap_noise_tri_erp(bn.y), \n                        remap_noise_tri_erp(bn.z) );\n    color += (bn_tri*2.0-1.5)/d;\n    #else\n    float bn = SAMPLER_FNC(tex, st * blueNoiseTexturePixel).r;\n    float bn_tri = remap_pdf_tri_unity(bn);\n    color += (bn_tri*2.0-1.5)/d;\n    #endif\n    return color;\n}\nfloat ditherBlueNoise(SAMPLER_TYPE tex, const in float b, vec2 st) { return ditherBlueNoise(tex, b, st, DITHER_BLUENOISE_PRECISION); }\nvec3 ditherBlueNoise(SAMPLER_TYPE tex, const in vec3 rgb, vec2 st) { return ditherBlueNoise(tex, rgb, st, DITHER_BLUENOISE_PRECISION);}\nvec4 ditherBlueNoise(SAMPLER_TYPE tex, const in vec4 rgba, vec2 st) { return vec4(ditherBlueNoise(tex, rgba.rgb, st), rgba.a); }\nfloat ditherBlueNoise(const in float val) { return ditherBlueNoise(BLUENOISE_TEXTURE, val, DITHER_BLUENOISE_COORD); }\nvec3 ditherBlueNoise(const in vec3 color) { return ditherBlueNoise(BLUENOISE_TEXTURE, color, DITHER_BLUENOISE_COORD); }\nvec4 ditherBlueNoise(const in vec4 color) { return ditherBlueNoise(BLUENOISE_TEXTURE, color, DITHER_BLUENOISE_COORD); }\n#else \nfloat ditherBlueNoise(vec2 p) {\n    const float SEED1 = 1.705;\n    const float size = 5.5;\n    p = floor(p);\n    vec2 p1 = p;\n    #ifdef DITHER_BLUENOISE_TIME\n    p += 1337.0*fract(DITHER_BLUENOISE_TIME * 0.1);\n    #else\n    p += 10.0;\n    #endif\n    p = floor(p/size)*size;\n    p = fract(p * 0.1) + 1.0 + p * vec2(0.0002, 0.0003);\n    float a = fract(1.0 / (0.000001 * p.x * p.y + 0.00001));\n    a = fract(1.0 / (0.000001234 * a + 0.00001));\n    float b = fract(1.0 / (0.000002 * (p.x * p.y + p.x) + 0.00001));\n    b = fract(1.0 / (0.0000235*b + 0.00001));\n    vec2 r = vec2(a, b) - 0.5;\n    p1 += r * 8.12235325;\n    return fract(p1.x * SEED1 + p1.y/(SEED1+0.15555));\n}\nvec3 ditherBlueNoise(const in vec3 color, const in vec2 xy, const int pres) {\n    float d = float(pres);\n    vec3 decimated = decimate(color, d);\n    vec3 diff = (color - decimated) * d;\n    return saturate(decimate(color + step(vec3(ditherBlueNoise(xy)), diff) / d, d));\n}\nfloat ditherBlueNoise(const in float val, const in vec2 xy, const int pres) { return ditherBlueNoise(vec3(val), xy, pres).r; }\nvec4 ditherBlueNoise(const in vec4 color, const in vec2 xy, const int pres) { return vec4(ditherBlueNoise(color.rgb, xy, pres), color.a); }\nfloat ditherBlueNoise(const in float val, const in vec2 xy) { return ditherBlueNoise(vec3(val), xy, DITHER_BLUENOISE_PRECISION).r; }\nvec3 ditherBlueNoise(const in vec3 color, const in vec2 xy) { return ditherBlueNoise(color, xy, DITHER_BLUENOISE_PRECISION); }  \nvec4 ditherBlueNoise(const in vec4 color, const in vec2 xy) {  return vec4(ditherBlueNoise(color.rgb, xy, DITHER_BLUENOISE_PRECISION), color.a); }\nfloat ditherBlueNoise(float val) { return ditherBlueNoise(val, DITHER_BLUENOISE_COORD, DITHER_BLUENOISE_PRECISION); }\nvec3 ditherBlueNoise(vec3 color) { return ditherBlueNoise(color, DITHER_BLUENOISE_COORD, DITHER_BLUENOISE_PRECISION); }\nvec4 ditherBlueNoise(vec4 color) { return ditherBlueNoise(color, DITHER_BLUENOISE_COORD, DITHER_BLUENOISE_PRECISION); }\n#endif\n#endif\n#ifndef DITHER_SHIFT_COORD\n#define DITHER_SHIFT_COORD gl_FragCoord.xy\n#endif\n#ifdef DITHER_TIME\n#define DITHER_SHIFT_TIME DITHER_TIME\n#endif\n#ifdef DITHER_CHROMATIC\n#define DITHER_SHIFT_CHROMATIC\n#endif\n#ifndef DITHER_SHIFT_PRECISION\n#ifdef DITHER_PRECISION\n#define DITHER_SHIFT_PRECISION DITHER_PRECISION\n#else\n#define DITHER_SHIFT_PRECISION 256\n#endif\n#endif\n#ifndef FNC_DITHER_SHIFT\n#define FNC_DITHER_SHIFT\nfloat ditherShift(const in float b, const in vec2 st, const int pres) {\n    float dither_bit = 8.0; \n    #ifdef DITHER_SHIFT_TIME \n    st += 1337.0*fract(DITHER_SHIFT_TIME);\n    #endif\n    float grid_position = fract( dot( st - vec2(0.5,0.5) , vec2(1.0/16.0,10.0/36.0) + 0.25 ) );\n    float dither_shift = (0.25) * (1.0 / (pow(2.0,dither_bit) - 1.0));\n    dither_shift = mix(2.0 * dither_shift, -2.0 * dither_shift, grid_position); \n    return b + 0.5/255.0 + dither_shift; \n}\nvec3 ditherShift(const in vec3 color, const in vec2 st, const int pres) {\n    float dither_bit = 8.0; \n    #ifdef DITHER_SHIFT_TIME \n    st += 1337.0*fract(DITHER_SHIFT_TIME);\n    #endif\n    float grid_position = fract( dot( st - vec2(0.5,0.5) , vec2(1.0/16.0,10.0/36.0) + 0.25 ) );\n    float dither_shift = (0.25) * (1.0 / (pow(2.0,dither_bit) - 1.0));\n    #ifdef DITHER_SHIFT_CHROMATIC\n    vec3 ditherPattern = vec3(dither_shift, -dither_shift, dither_shift);\n    #else\n    vec3 ditherPattern = vec3(dither_shift);\n    #endif\n    ditherPattern = mix(2.0 * ditherPattern, -2.0 * ditherPattern, grid_position); \n    float d = float(pres);\n    float h = 0.5/d;\n    return decimate(color + h + ditherPattern, d);\n}\nfloat ditherShift(const in float value, const in vec2 xy) {  return ditherShift(value, xy, DITHER_SHIFT_PRECISION); }\nvec3 ditherShift(const in vec3 color, const in vec2 xy) {  return ditherShift(color, xy, DITHER_SHIFT_PRECISION); }\nvec4 ditherShift(const in vec4 color, const in vec2 xy) {  return vec4(ditherShift(color.rgb, xy, DITHER_SHIFT_PRECISION), color.a); }\nfloat ditherShift(const in float val, int pres) { return ditherShift(vec3(val),DITHER_SHIFT_COORD, pres).r; }\nvec3 ditherShift(const in vec3 color, int pres) { return ditherShift(color, DITHER_SHIFT_COORD, pres); }\nvec4 ditherShift(const in vec4 color, int pres) { return vec4(ditherShift(color.rgb, DITHER_SHIFT_COORD, pres), color.a); }\nfloat ditherShift(const in float val) { return ditherShift(vec3(val), DITHER_SHIFT_COORD, DITHER_SHIFT_PRECISION).r; }\nvec3 ditherShift(const in vec3 color) { return ditherShift(color, DITHER_SHIFT_COORD, DITHER_SHIFT_PRECISION); }\nvec4 ditherShift(const in vec4 color) { return vec4(ditherShift(color.rgb), color.a); }\n#endif\n#ifndef DITHER_BAKER_COORD\n#define DITHER_BAKER_COORD gl_FragCoord.xy\n#endif\n#ifndef DITHER_BAYER_PRECISION\n#ifdef DITHER_PRECISION\n#define DITHER_BAYER_PRECISION DITHER_PRECISION\n#else\n#define DITHER_BAYER_PRECISION 256\n#endif\n#endif\n#ifndef FNC_DITHER_BAYER\n#define FNC_DITHER_BAYER\n#if defined(PLATFORM_WEBGL)\nfloat ditherBayer(const in vec2 xy) {\n    float x = mod(xy.x, 8.0);\n    float y = mod(xy.y, 8.0);\n    return  mix(mix(mix(mix(mix(mix(0.0,32.0,step(1.0,y)),mix(8.0,40.0,step(3.0,y)),step(2.0,y)),mix(mix(2.0,34.0,step(5.0,y)),mix(10.0,42.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),mix(mix(mix(48.0,16.0,step(1.0,y)),mix(56.0,24.0,step(3.0,y)),step(2.0,y)),mix(mix(50.0,18.0,step(5.0,y)),mix(58.0,26.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),step(1.0,x)),mix(mix(mix(mix(12.0,44.0,step(1.0,y)),mix(4.0,36.0,step(3.0,y)),step(2.0,y)),mix(mix(14.0,46.0,step(5.0,y)),mix(6.0,38.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),mix(mix(mix(60.0,28.0,step(1.0,y)),mix(52.0,20.0,step(3.0,y)),step(2.0,y)),mix(mix(62.0,30.0,step(5.0,y)),mix(54.0,22.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),step(3.0,x)),step(2.0,x)),mix(mix(mix(mix(mix(3.0,35.0,step(1.0,y)),mix(11.0,43.0,step(3.0,y)),step(2.0,y)),mix(mix(1.0,33.0,step(5.0,y)),mix(9.0,41.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),mix(mix(mix(51.0,19.0,step(1.0,y)),mix(59.0,27.0,step(3.0,y)),step(2.0,y)),mix(mix(49.0,17.0,step(5.0,y)),mix(57.0,25.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),step(5.0,x)),mix(mix(mix(mix(15.0,47.0,step(1.0,y)),mix(7.0,39.0,step(3.0,y)),step(2.0,y)),mix(mix(13.0,45.0,step(5.0,y)),mix(5.0,37.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),mix(mix(mix(63.0,31.0,step(1.0,y)),mix(55.0,23.0,step(3.0,y)),step(2.0,y)),mix(mix(61.0,29.0,step(5.0,y)),mix(53.0,21.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),step(7.0,x)),step(6.0,x)),step(4.0,x)) / (64.0);\n}\n#else\nfloat ditherBayer(const in vec2 xy) {\n    float kern[64];\n    kern[ 0] = 0.000; kern[ 1] = 0.500; kern[ 2] = 0.124; kern[ 3] = 0.624; kern[ 4] = 0.028; kern[ 5] = 0.532; kern[ 6] = 0.156; kern[ 7] = 0.656; \n    kern[ 8] = 0.752; kern[ 9] = 0.248; kern[10] = 0.876; kern[11] = 0.376; kern[12] = 0.784; kern[13] = 0.280; kern[14] = 0.908; kern[15] = 0.404; \n    kern[16] = 0.188; kern[17] = 0.688; kern[18] = 0.060; kern[19] = 0.564; kern[20] = 0.216; kern[21] = 0.720; kern[22] = 0.092; kern[23] = 0.596; \n    kern[24] = 0.940; kern[25] = 0.436; kern[26] = 0.812; kern[27] = 0.312; kern[28] = 0.972; kern[29] = 0.468; kern[30] = 0.844; kern[31] = 0.344; \n    kern[32] = 0.044; kern[33] = 0.548; kern[34] = 0.172; kern[35] = 0.672; kern[36] = 0.012; kern[37] = 0.516; kern[38] = 0.140; kern[39] = 0.640; \n    kern[40] = 0.800; kern[41] = 0.296; kern[42] = 0.924; kern[43] = 0.420; kern[44] = 0.768; kern[45] = 0.264; kern[46] = 0.892; kern[47] = 0.392; \n    kern[48] = 0.232; kern[49] = 0.736; kern[50] = 0.108; kern[51] = 0.608; kern[52] = 0.200; kern[53] = 0.704; kern[54] = 0.076; kern[55] = 0.580; \n    kern[56] = 0.988; kern[57] = 0.484; kern[58] = 0.860; kern[59] = 0.360; kern[60] = 0.956; kern[61] = 0.452; kern[62] = 0.828; kern[63] = 0.328;\n    int index = int(mod(xy.x, 8.0)) + (int(mod(xy.y, 8.0)) * 8);\n    #if defined(PLATFORM_WEBGL)\n    for (int i = 0; i < 64; i++) if (i == index) return kern[i];\n    #else\n    return kern[index];\n    #endif\n}\n#endif\nvec3 ditherBayer(vec3 color, const in vec2 xy, const int pres) {\n    float d = float(pres);\n    vec3 decimated = decimate(color, d);\n    vec3 diff = (color - decimated) * d;\n    vec3 ditherPattern = vec3(ditherBayer(xy));\n    return decimate(color + (step(ditherPattern, diff) / d), d);\n}\nfloat ditherBayer(const in float val, const in vec2 xy) { return ditherBayer(vec3(val), xy, DITHER_BAYER_PRECISION).r; }\nvec3 ditherBayer(const in vec3 color, const in vec2 xy) {  return ditherBayer(color, xy, DITHER_BAYER_PRECISION); }\nvec4 ditherBayer(const in vec4 color, const in vec2 xy) {  return vec4(ditherBayer(color.rgb, xy, DITHER_BAYER_PRECISION), color.a); }\nfloat ditherBayer(const in float val, int pres) { return ditherBayer(vec3(val),DITHER_BAKER_COORD, pres).r; }\nvec3 ditherBayer(const in vec3 color, int pres) { return ditherBayer(color, DITHER_BAKER_COORD, pres); }\nvec4 ditherBayer(const in vec4 color, int pres) { return vec4(ditherBayer(color.rgb, DITHER_BAKER_COORD, pres), color.a); }\nfloat ditherBayer(const in float val) { return ditherBayer(vec3(val), DITHER_BAKER_COORD, DITHER_BAYER_PRECISION).r; }\nvec3 ditherBayer(const in vec3 color) { return ditherBayer(color, DITHER_BAKER_COORD, DITHER_BAYER_PRECISION); }\nvec4 ditherBayer(const in vec4 color) { return vec4(ditherBayer(color.rgb), color.a); }\n#endif\n#ifndef DITHER_FNC\n#ifdef TARGET_MOBILE\n#define DITHER_FNC ditherInterleavedGradientNoise\n#else\n#define DITHER_FNC ditherVlachos\n#endif\n#endif\n#ifndef FNC_DITHER\n#define FNC_DITHER\nfloat dither(float v) { return DITHER_FNC(v); }\nvec3 dither(vec3 v) { return DITHER_FNC(v); }\nvec4 dither(vec4 v) { return DITHER_FNC(v); }\n#endif\n#if !defined(GAMMA) && !defined(TARGET_MOBILE) && !defined(PLATFORM_RPI) && !defined(PLATFORM_WEBGL)\n#define GAMMA 2.2\n#endif\n#ifndef FNC_GAMMA2LINEAR\n#define FNC_GAMMA2LINEAR\nfloat gamma2linear(const in float v) {\n#ifdef GAMMA\n    return pow(v, GAMMA);\n#else\n    return v * v;\n#endif\n}\nvec3 gamma2linear(const in vec3 v) {\n#ifdef GAMMA\n    return pow(v, vec3(GAMMA));\n#else\n    return v * v;\n#endif\n}\nvec4 gamma2linear(const in vec4 v) {\n    return vec4(gamma2linear(v.rgb), v.a);\n}\n#endif\n#if !defined(GAMMA) && !defined(TARGET_MOBILE) && !defined(PLATFORM_RPI) && !defined(PLATFORM_WEBGL)\n#define GAMMA 2.2\n#endif\n#ifndef FNC_LINEAR2GAMMA\n#define FNC_LINEAR2GAMMA\nvec3 linear2gamma(const in vec3 v) {\n#ifdef GAMMA\n    return pow(v, vec3(1.0/GAMMA));\n#else\n    return sqrt(v);\n#endif\n}\nvec4 linear2gamma(const in vec4 v) {\n    return vec4(linear2gamma(v.rgb), v.a);\n}\nfloat linear2gamma(const in float v) {\n#ifdef GAMMA\n    return pow(v, 1.0/GAMMA);\n#else\n    return sqrt(v);\n#endif\n}\n#endif\n#ifndef SAMPLEDITHER_FNC\n#define SAMPLEDITHER_FNC ditherBayer\n#endif\n#ifndef FNC_SAMPLEDITHER\n#define FNC_SAMPLEDITHER\nvec4 sampleDither(SAMPLER_TYPE tex, const in vec2 st, const in vec2 resolution) {\n    vec4 color = sampleNearest(tex, st, resolution);\n    gamma2linear(color);\n    color = SAMPLEDITHER_FNC(color, st * resolution);\n    linear2gamma(color);\n    return color;\n}\n#endif\n        vec4 filter_Dither(){\n          vec2 pixel = 1.0/u_resolution.xy;\n          vec2 st = gl_FragCoord.xy * pixel;\n          vec2 ditherResolution = u_resolution/u_filter_dither_size;\n          vec4 color = sampleNearest(u_texture, st, ditherResolution);\n          gamma2linear(color);\n          if(u_filter_dither_type[0]){\n            color = ditherBayer(color,st * ditherResolution);\n          } else if(u_filter_dither_type[1]){\n            color = ditherBlueNoise(color,st * ditherResolution);\n          } else if(u_filter_dither_type[2]){\n            color = ditherTriangleNoise(color,st * ditherResolution);\n          } else if(u_filter_dither_type[3]){\n            color = ditherInterleavedGradientNoise(color,st * ditherResolution);\n          } else if(u_filter_dither_type[4]){\n            color = ditherVlachos(color,st * ditherResolution);\n          } else if(u_filter_dither_type[5]){\n            color = ditherShift(color,st * ditherResolution);\n          }\n          linear2gamma(color);\n          return color;\n        }\n        void main() {\n      glFragColor = filter_Dither();\n        }","#version 300 es\n    precision highp float;\n    out vec4 glFragColor;\n        uniform sampler2D u_texture;\n        uniform vec2 u_resolution;\n        uniform float u_time;\n        #define PASS_0 true\n        vec4 filter_getFragColor(vec2 coord){\n            return texture(u_texture, fract(coord));\n        }\n        vec4 filter_getClampedFragColor(vec2 coord){\n            return texture(u_texture, clamp(coord, vec2(0.01), vec2(0.99)) );\n        }\n        vec4 filter_getClampedFragColor(vec2 coord, float edge){\n            return texture(u_texture, clamp(coord, vec2(edge), vec2(1.0 - edge)) );\n        }\n      uniform bool u_palette[11]; \n      uniform bool u_color_bleed;\n#ifndef FNC_RGB2LUMA\n#define FNC_RGB2LUMA\nfloat rgb2luma(in vec3 color) {\n    return dot(color, vec3(0.299, 0.587, 0.114));\n}\nfloat rgb2luma(in vec4 color) {\n    return rgb2luma(color.rgb);\n}\n#endif\n#ifndef FNC_LUMA\n#define FNC_LUMA\nfloat luma(float v) { return v; }\nfloat luma(in vec3 v) { return rgb2luma(v); }\nfloat luma(in vec4 v) { return rgb2luma(v.rgb); }\n#endif\n      vec3 colorBleed(sampler2D tex, vec2 uv, vec2 texelSize) {\n          vec3 center = texture(tex, uv).rgb;\n          vec3 left = texture(tex, uv - vec2(texelSize.x, 0.0)).rgb;\n          vec3 right = texture(tex, uv + vec2(texelSize.x, 0.0)).rgb;\n          return mix(center, (left + right) * 0.5, 0.2);\n      }\n      vec3 smsColor(vec3 color) {\n          vec3 quantized = floor(color * 3.0) / 3.0;\n          return vec3(\n              float(int(quantized.r * 3.0 + 0.5)) / 3.0,\n              float(int(quantized.g * 3.0 + 0.5)) / 3.0,\n              float(int(quantized.b * 3.0 + 0.5)) / 3.0\n          );\n      }\n      vec3 amigaColor(vec3 color) {\n          float gray = dot(color, vec3(0.299, 0.587, 0.114));\n          vec3 amiga_colors[16] = vec3[16](\n              vec3(0.40, 0.40, 0.40), \n              vec3(0.00, 0.00, 0.00), \n              vec3(1.00, 1.00, 1.00), \n              vec3(0.62, 0.45, 0.31), \n              vec3(0.00, 0.00, 0.50), \n              vec3(0.50, 0.00, 0.50), \n              vec3(0.00, 0.50, 0.50), \n              vec3(0.50, 0.50, 0.00), \n              vec3(0.31, 0.31, 0.31), \n              vec3(0.50, 0.25, 0.00), \n              vec3(0.75, 0.75, 0.75), \n              vec3(1.00, 0.50, 0.00), \n              vec3(0.00, 0.00, 1.00), \n              vec3(1.00, 0.00, 1.00), \n              vec3(0.00, 1.00, 1.00), \n              vec3(1.00, 1.00, 0.00)  \n          );\n          vec3 finalColor = amiga_colors[0];\n          float minDist = 999.0;\n          for (int i = 0; i < 16; i++) {\n              float dist = distance(color, amiga_colors[i]);\n              if (dist < minDist) {\n                  minDist = dist;\n                  finalColor = amiga_colors[i];\n              }\n          }\n          return finalColor;\n      }\n      vec3 gameboyOGColor(vec3 color) {\n          float gray = dot(color, vec3(0.299, 0.587, 0.114));\n          vec3 darkest = vec3(0.043, 0.172, 0.027);  \n          vec3 dark = vec3(0.145, 0.368, 0.059);     \n          vec3 light = vec3(0.392, 0.615, 0.086);    \n          vec3 lightest = vec3(0.607, 0.745, 0.058); \n          if (gray < 0.25) return darkest;\n          else if (gray < 0.5) return dark;\n          else if (gray < 0.75) return light;\n          else return lightest;\n      }\n      vec3 gameboyPocketColor(vec3 color) {\n          float gray = dot(color, vec3(0.299, 0.587, 0.114));\n          vec3 darkest = vec3(0.04);  \n          vec3 dark = vec3(0.29);     \n          vec3 light = vec3(0.61);    \n          vec3 lightest = vec3(0.89); \n          if (gray < 0.25) return darkest;\n          else if (gray < 0.5) return dark;\n          else if (gray < 0.75) return light;\n          else return lightest;\n      }\n      vec3 gbcColor(vec3 color) {\n          vec3 gbc = floor(color * 31.0 + 0.5); \n          mat3 colorCorrection = mat3(\n              1.05, 0.0, 0.0,\n              0.0, 0.95, 0.0,\n              0.0, 0.0, 0.98\n          );\n          gbc = (colorCorrection * gbc) / 31.0;\n          gbc = clamp(gbc * 1.2 - 0.1, 0.0, 1.0);\n          return gbc;\n      }\n      vec3 cgaColor(vec3 color) {\n          float gray = dot(color, vec3(0.299, 0.587, 0.114));\n          vec3 black = vec3(0.0, 0.0, 0.0);           \n          vec3 cyan = vec3(0.333, 1.0, 1.0);          \n          vec3 magenta = vec3(1.0, 0.333, 1.0);       \n          vec3 white = vec3(1.0, 1.0, 1.0);           \n          if (gray < 0.25) return black;\n          else if (gray < 0.5) return cyan;\n          else if (gray < 0.75) return magenta;\n          else return white;\n      }\n      vec3 monochrome2bit(vec3 color) {\n          float gray = dot(color, vec3(0.299, 0.587, 0.114));\n          gray = floor(gray * 3.999) / 3.0;\n          return vec3(gray);\n      }\n      vec3 zxSpectrumColor(vec3 color) {\n          float brightness = dot(color, vec3(0.299, 0.587, 0.114));\n          bool isBright = brightness > 0.6; \n          vec3 spectrum_colors[8] = vec3[8](\n              vec3(0.0, 0.0, 0.0),      \n              vec3(0.0, 0.0, 0.7),      \n              vec3(0.7, 0.0, 0.0),      \n              vec3(0.7, 0.0, 0.7),      \n              vec3(0.0, 0.7, 0.0),      \n              vec3(0.0, 0.7, 0.7),      \n              vec3(0.7, 0.7, 0.0),      \n              vec3(0.7, 0.7, 0.7)       \n          );\n          vec3 spectrum_bright[8] = vec3[8](\n              vec3(0.0, 0.0, 0.0),      \n              vec3(0.0, 0.0, 1.0),      \n              vec3(1.0, 0.0, 0.0),      \n              vec3(1.0, 0.0, 1.0),      \n              vec3(0.0, 1.0, 0.0),      \n              vec3(0.0, 1.0, 1.0),      \n              vec3(1.0, 1.0, 0.0),      \n              vec3(1.0, 1.0, 1.0)       \n          );\n          vec3 finalColor = spectrum_colors[0];\n          float minDist = 999.0;\n          for (int i = 0; i < 8; i++) {\n              vec3 targetColor = isBright ? spectrum_bright[i] : spectrum_colors[i];\n              float dist = distance(color, targetColor);\n              if (dist < minDist) {\n                  minDist = dist;\n                  finalColor = targetColor;\n              }\n          }\n          return finalColor;\n      }\n      vec3 nesColor(vec3 color) {\n          vec3 nesPalette[16] = vec3[16](\n              vec3(0.47, 0.47, 0.47), \n              vec3(0.94, 0.94, 0.94), \n              vec3(0.84, 0.23, 0.15), \n              vec3(0.96, 0.47, 0.20), \n              vec3(0.98, 0.74, 0.16), \n              vec3(0.54, 0.89, 0.20), \n              vec3(0.21, 0.72, 0.47), \n              vec3(0.22, 0.59, 0.89), \n              vec3(0.29, 0.29, 0.84), \n              vec3(0.56, 0.27, 0.82), \n              vec3(0.89, 0.36, 0.71), \n              vec3(0.40, 0.22, 0.00), \n              vec3(0.69, 0.69, 0.69), \n              vec3(0.26, 0.26, 0.26), \n              vec3(0.00, 0.00, 0.00), \n              vec3(1.00, 1.00, 1.00)  \n          );\n          vec3 finalColor = nesPalette[0];\n          float minDist = 999.0;\n          for (int i = 0; i < 16; i++) {\n              float dist = distance(color, nesPalette[i]);\n              if (dist < minDist) {\n                  minDist = dist;\n                  finalColor = nesPalette[i];\n              }\n          }\n          return finalColor;\n      }\n      vec3 c64Color(vec3 color) {\n          float gray = dot(color, vec3(0.299, 0.587, 0.114));\n          vec3 c64_colors[16] = vec3[16](\n              vec3(0.0, 0.0, 0.0),        \n              vec3(1.0, 1.0, 1.0),        \n              vec3(0.47, 0.20, 0.20),     \n              vec3(0.42, 0.87, 0.87),     \n              vec3(0.49, 0.20, 0.47),     \n              vec3(0.20, 0.62, 0.20),     \n              vec3(0.20, 0.20, 0.67),     \n              vec3(0.80, 0.75, 0.20),     \n              vec3(0.47, 0.31, 0.20),     \n              vec3(0.31, 0.22, 0.13),     \n              vec3(0.67, 0.38, 0.38),     \n              vec3(0.33, 0.33, 0.33),     \n              vec3(0.47, 0.47, 0.47),     \n              vec3(0.47, 0.87, 0.47),     \n              vec3(0.40, 0.40, 0.87),     \n              vec3(0.67, 0.67, 0.67)      \n          );\n          vec3 finalColor = c64_colors[0];\n          float minDist = 999.0;\n          for (int i = 0; i < 16; i++) {\n              float dist = distance(color, c64_colors[i]);\n              if (dist < minDist) {\n                  minDist = dist;\n                  finalColor = c64_colors[i];\n              }\n          }\n          return finalColor;\n      }\n      vec3 atari2600Color(vec3 color) {\n          mat3 rgb2yiq = mat3(\n              0.299, 0.587, 0.114,\n              0.596, -0.274, -0.322,\n              0.211, -0.523, 0.312\n          );\n          vec3 yiq = rgb2yiq * color;\n          vec3 tia_colors[16] = vec3[16](\n              vec3(0.000,  0.000,  0.000),  \n              vec3(1.000,  0.000,  0.000),  \n              vec3(0.310,  0.436,  0.178),  \n              vec3(0.627, -0.399, -0.158),  \n              vec3(0.373,  0.280, -0.238),  \n              vec3(0.529, -0.339,  0.149),  \n              vec3(0.265,  0.016, -0.289),  \n              vec3(0.843, -0.145,  0.247),  \n              vec3(0.467,  0.465,  0.167),  \n              vec3(0.278,  0.267,  0.153),  \n              vec3(0.537,  0.387,  0.127),  \n              vec3(0.286,  0.000,  0.000),  \n              vec3(0.482,  0.000,  0.000),  \n              vec3(0.643, -0.308,  0.151),  \n              vec3(0.373,  0.042, -0.247),  \n              vec3(0.729,  0.000,  0.000)   \n          );\n          float artifactPhase = 0.0;\n          const float artifactFreq = 3.579545; \n          const float dotCrawlAmount = 0.075;\n          vec3 finalColor = tia_colors[0];\n          float minDist = 999.0;\n          for (int i = 0; i < 16; i++) {\n              vec3 weights = vec3(1.2, 0.8, 0.8);\n              vec3 delta = (yiq - tia_colors[i]) * weights;\n              float dist = dot(delta, delta);\n              if (dist < minDist) {\n                  minDist = dist;\n                  finalColor = tia_colors[i];\n              }\n          }\n          vec2 pos = gl_FragCoord.xy;\n          artifactPhase = mod(pos.x + pos.y, 2.0) * 3.14159;\n          float dotCrawl = sin(artifactPhase + u_time * 2.0) * dotCrawlAmount;\n          finalColor.x += dotCrawl; \n          mat3 yiq2rgb = mat3(\n              1.000,  0.956,  0.621,\n              1.000, -0.272, -0.647,\n              1.000, -1.105,  1.702\n          );\n          vec3 rgb = yiq2rgb * finalColor;\n          float persistence = 0.15;\n          vec2 prevPos = pos - vec2(1.0, 0.0); \n          vec3 prevColor = texture(u_texture, prevPos/u_resolution).rgb;\n          rgb = mix(rgb, prevColor, persistence);\n          float bleed = 0.1;\n          vec3 neighborColor = texture(u_texture, (pos + vec2(1.0, 0.0))/u_resolution).rgb;\n          rgb = mix(rgb, neighborColor, bleed);\n          return clamp(rgb, 0.0, 1.0);\n      }\n      vec4 filter_RetroColors(){\n        vec2 uv = gl_FragCoord.xy/u_resolution;\n        vec4 color = filter_getFragColor(uv);\n        if(u_color_bleed){\n          color.rgb = colorBleed(u_texture, uv, 1.0/u_resolution.xy);\n        }\n        if(u_palette[0]){\n          color.rgb = gameboyOGColor(color.rgb);\n        } else if(u_palette[1]){\n          color.rgb = gameboyPocketColor(color.rgb);\n        } else if(u_palette[2]){\n          color.rgb = gbcColor(color.rgb);\n        } else if(u_palette[3]){\n          color.rgb = cgaColor(color.rgb);\n        } else if(u_palette[4]){\n          color.rgb = monochrome2bit(color.rgb);\n        } else if(u_palette[5]){\n          color.rgb = zxSpectrumColor(color.rgb);\n        } else if(u_palette[6]){\n          color.rgb = nesColor(color.rgb);\n        } else if(u_palette[7]){\n          color.rgb = c64Color(color.rgb);\n        } else if(u_palette[8]){\n          color.rgb = smsColor(color.rgb);\n        } else if(u_palette[9]){\n          color.rgb = amigaColor(color.rgb);\n        } else if(u_palette[10]){\n          color.rgb = atari2600Color(color.rgb);\n        }\n        return color;\n      }\n        void main() {\n      glFragColor = filter_RetroColors();\n        }"]'
              uniforms='[{"u_filter_tiles":2},{"u_filter_dither_type":[true,false,false,false,false,false],"u_filter_dither_size":2,"u_filter_precision":2},{"u_palette":[true,false,true,false,false,false,false,false,false,false,false],"u_color_bleed":false}]'>
</media-shader>

<script>
    let btn = document.querySelector('button')
    let ms = document.querySelector('media-shader')

    // Initial uniforms
    let uniforms = [
        { "u_filter_tiles": 2 },
        { "u_filter_dither_type": [true, false, false, false, false, false], "u_filter_dither_size": 2, "u_filter_precision": 2 },
        { "u_palette": [true, false, true, false, false, false, false, false, false, false, false], "u_color_bleed": false }
    ];

    // Update uniforms function
    function updateUniforms() {
        ms.setAttribute('uniforms', JSON.stringify(uniforms));
    }

    // Tiles slider
    const tilesSlider = document.getElementById('tiles-slider');
    const tilesValue = document.getElementById('tiles-value');
    tilesSlider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        uniforms[0].u_filter_tiles = value;
        tilesValue.textContent = value.toFixed(1);
        updateUniforms();
    });

    // Dither size slider
    const ditherSizeSlider = document.getElementById('dither-size-slider');
    const ditherSizeValue = document.getElementById('dither-size-value');
    ditherSizeSlider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        uniforms[1].u_filter_dither_size = value;
        ditherSizeValue.textContent = value.toFixed(1);
        updateUniforms();
    });

    // Precision slider
    const precisionSlider = document.getElementById('precision-slider');
    const precisionValue = document.getElementById('precision-value');
    precisionSlider.addEventListener('input', (e) => {
        const value = parseInt(e.target.value);
        uniforms[1].u_filter_precision = value;
        precisionValue.textContent = value;
        updateUniforms();
    });

    // Play button
    btn.addEventListener('click', e => {
        let video = ms.querySelector("video")
        console.log(video)
        ms.setAttribute("playing", "true")
        ms.muted = false
        ms.volume = .05
    })
</script>